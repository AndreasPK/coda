-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The coda compiler
--   
--   This package provides Coda, a Visual Studio Code language experiment.
@package coda
@version 0.0.1.0

module Coda.Syntax.Delta

-- | <tt>AlexInput</tt> torsor, this is a (potentially relative) position
data Delta
Delta :: !Int -> !Int -> !Int -> Delta
[deltaLine] :: Delta -> !Int
[deltaCol16] :: Delta -> !Int
[deltaCol8] :: Delta -> !Int

-- | Applying a relative position change as a left monoid action
--   
--   Laws:
--   
--   <pre>
--   <a>rel</a> <a>mempty</a> ≡ <a>id</a>
--   <a>rel</a> (m <a>&lt;&gt;</a> n) ≡ <a>rel</a> m . <a>rel</a> n
--   </pre>
class Relative t
rel :: Relative t => Delta -> t -> t
instance Data.Hashable.Class.Hashable Coda.Syntax.Delta.Delta
instance GHC.Generics.Generic Coda.Syntax.Delta.Delta
instance Data.Data.Data Coda.Syntax.Delta.Delta
instance GHC.Read.Read Coda.Syntax.Delta.Delta
instance GHC.Show.Show Coda.Syntax.Delta.Delta
instance GHC.Classes.Ord Coda.Syntax.Delta.Delta
instance GHC.Classes.Eq Coda.Syntax.Delta.Delta
instance Data.Semigroup.Semigroup Coda.Syntax.Delta.Delta
instance GHC.Base.Monoid Coda.Syntax.Delta.Delta
instance Coda.Syntax.Delta.Relative Coda.Syntax.Delta.Delta

module Coda.Version

-- | Grab the version number from this project.
version :: String

module Coda.Util.STM
class MonadBase STM m => MonadSTM m

-- | <pre>
--   <a>liftSTM</a> = <a>liftBase</a>
--   </pre>
liftSTM :: MonadSTM t => STM a -> t a
instance Control.Monad.Base.MonadBase GHC.Conc.Sync.STM m => Coda.Util.STM.MonadSTM m

module Coda.Util.Primitive
shrinkMutableByteArray :: PrimMonad m => MutableByteArray (PrimState m) -> Int -> m ()


-- | General-purpose utilities for pretty printing.
module Coda.Util.Pretty

-- | This is an infinitely large free variable supply you can trim your
--   used variables out of.
names :: [String]

-- | Pretty print parentheses
parensIf :: Bool -> Doc -> Doc

-- | Hyphenate a word using standard TeX-style <a>english_US</a>
--   hyphenation.
hyph :: String -> Doc
prePunctuate :: Doc -> [Doc] -> [Doc]
prePunctuate' :: Doc -> Doc -> [Doc] -> [Doc]

-- | Format a layout block in explicit style.
block :: [Doc] -> Doc

-- | Pretty print to <a>stdout</a>
say :: MonadIO m => Doc -> m ()

-- | Pretty print to <a>stdout</a> with a <a>linebreak</a> after.
sayLn :: MonadIO m => Doc -> m ()

module Coda.Util.Async
waitAll :: [Async a] -> IO [a]
waitAllSTM :: [Async a] -> STM [a]
waitAll_ :: [Async a] -> IO ()
waitAllSTM_ :: [Async a] -> STM ()


-- | Missing instances
module Coda.Util.Instances
instance Data.Aeson.Types.ToJSON.ToJSON Data.Void.Void
instance Data.Aeson.Types.FromJSON.FromJSON Data.Void.Void


-- | This module provides a couple of ad hoc combinators that make it
--   easier to share code (at least in style) between <a>toEncoding</a> and
--   <a>toJSON</a> definitions for <a>ToJSON</a>.
module Coda.Util.Aeson
class Monoid (Ob v) => FromHook v where type Ob v :: * where {
    type family Ob v :: *;
}
(!=) :: FromHook v => Text -> v -> Ob v
class Monoid t => ToHook t
(!~) :: (ToHook t, ToJSON v) => Text -> v -> t
(?~) :: (ToJSON v, ToHook t) => Text -> Maybe v -> t
infixr 8 ?~
(?=) :: FromHook v => Text -> Maybe v -> Ob v
infixr 8 ?=
(??~) :: (ToJSON a, ToHook r) => Text -> a -> r
infixr 8 ??~
parseMissingAsNull :: FromJSON a => Object -> Text -> Parser a
instance x ~ Data.Aeson.Types.Internal.Value => Coda.Util.Aeson.FromHook (Data.Aeson.Encoding.Internal.Encoding' x)
instance Coda.Util.Aeson.FromHook Data.Aeson.Types.Internal.Value
instance Coda.Util.Aeson.ToHook Data.Aeson.Encoding.Internal.Series
instance x ~ (Data.Text.Internal.Text, Data.Aeson.Types.Internal.Value) => Coda.Util.Aeson.ToHook [x]


module Coda.Syntax.Keywords

-- | These are keywords that may occur anywhere in a source file
keywords :: Set String

-- | these are keywords that are only valid at the start of a top level
--   statement
startingKeywords :: Set String

-- | These are keywords that introduce layout
layoutKeywords :: Set String


module Coda.Server.Options

-- | Options for <tt>coda server</tt>
data ServerOptions
ServerOptions :: !Bool -> !(Maybe FilePath) -> ServerOptions
[_serverOptionsDebug] :: ServerOptions -> !Bool
[_serverOptionsLog] :: ServerOptions -> !(Maybe FilePath)
class HasServerOptions c_aPpE where serverOptionsDebug = (.) serverOptions serverOptionsDebug serverOptionsLog = (.) serverOptions serverOptionsLog
serverOptions :: HasServerOptions c_aPpE => Lens' c_aPpE ServerOptions
serverOptionsDebug :: HasServerOptions c_aPpE => Lens' c_aPpE Bool
serverOptionsLog :: HasServerOptions c_aPpE => Lens' c_aPpE (Maybe FilePath)

-- | Parse <tt>coda server</tt> options
parseServerOptions :: Parser ServerOptions
instance Coda.Server.Options.HasServerOptions Coda.Server.Options.ServerOptions
instance Data.Data.Data Coda.Server.Options.ServerOptions
instance GHC.Read.Read Coda.Server.Options.ServerOptions
instance GHC.Show.Show Coda.Server.Options.ServerOptions
instance GHC.Classes.Ord Coda.Server.Options.ServerOptions
instance GHC.Classes.Eq Coda.Server.Options.ServerOptions


-- | <a>Language Server Protocol</a>
module Coda.Message.Severity

-- | See <tt>DiagnosticSeverity</tt> in
--   
--   
--   <a>https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#diagnostic</a>
newtype Severity
Severity :: Int -> Severity

-- | Reports an error.

-- | Reports a warning.

-- | Reports information

-- | Reports a hint
instance GHC.Generics.Generic Coda.Message.Severity.Severity
instance Data.Data.Data Coda.Message.Severity.Severity
instance GHC.Arr.Ix Coda.Message.Severity.Severity
instance GHC.Enum.Bounded Coda.Message.Severity.Severity
instance GHC.Enum.Enum Coda.Message.Severity.Severity
instance GHC.Classes.Ord Coda.Message.Severity.Severity
instance GHC.Classes.Eq Coda.Message.Severity.Severity
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Severity.Severity
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Severity.Severity
instance Data.Hashable.Class.Hashable Coda.Message.Severity.Severity
instance GHC.Show.Show Coda.Message.Severity.Severity
instance GHC.Read.Read Coda.Message.Severity.Severity


-- | JSON-RPC 2.0 message parsing
module Coda.Message.Parser

-- | This parser consumes lazy bytestrings
newtype Parser a
Parser :: (ByteString -> ParseResult a) -> Parser a
[runParser] :: Parser a -> ByteString -> ParseResult a

-- | The result of parsing
data ParseResult a
Err :: ParseResult a
OK :: !a -> !ByteString -> ParseResult a

-- | This parses a JSON-RPC 2.0 message
--   
--   This stops before we get to actually decoding the JSON message.
message :: Parser ByteString

-- | This decodes a JSON-RPC 2.0 message lazily
--   
--   If the outer parser fails, then the message stream is unrecoverable.
--   If decoding fails, we simply failed to read this message.
decodeMessage :: FromJSON a => Parser (Maybe a)

-- | This decodes a JSON-RPC 2.0 message eager
--   
--   If the outer parser fails, then the message stream is unrecoverable.
--   If decoding fails, we simply failed to read this message.
decodeMessage' :: FromJSON a => Parser (Maybe a)

-- | This decodes a JSON-RPC 2.0 message lazily with an error message on
--   failure
eitherDecodeMessage :: FromJSON a => Parser (Either String a)

-- | This decodes a JSON-RPC 2.0 message eager with an error message on
--   failure
eitherDecodeMessage' :: FromJSON a => Parser (Either String a)
instance GHC.Base.Functor Coda.Message.Parser.Parser
instance Data.Traversable.Traversable Coda.Message.Parser.ParseResult
instance Data.Foldable.Foldable Coda.Message.Parser.ParseResult
instance GHC.Base.Functor Coda.Message.Parser.ParseResult
instance GHC.Show.Show a => GHC.Show.Show (Coda.Message.Parser.ParseResult a)
instance GHC.Base.Applicative Coda.Message.Parser.Parser
instance GHC.Base.Monad Coda.Message.Parser.Parser
instance GHC.Base.Alternative Coda.Message.Parser.Parser
instance GHC.Base.MonadPlus Coda.Message.Parser.Parser
instance Control.Monad.Fail.MonadFail Coda.Message.Parser.Parser


-- | JSON-RPC 2.0 message serialization
module Coda.Message.Builder

-- | Serialize a JSON-RPC 2.0 message.
--   
--   <pre>
--   &gt;&gt;&gt; toLazyByteString (buildMessage "hello")
--   "Content-Length: 7\r\n\r\n\"hello\""
--   </pre>
buildMessage :: ToJSON a => a -> Builder

-- | Serialize a JSON-RPC 2.0 message from an Encoding
buildEncoding :: Encoding -> Builder

-- | Write a JSON-RPC 2.0 message to a given file handle
hPutMessage :: ToJSON a => Handle -> a -> IO ()

-- | Write a JSON-RPC 2.0 message to a given file handle from an Encoding
hPutEncoding :: Handle -> Encoding -> IO ()

-- | Write a JSON-RPC 2.0 message to stdout
putMessage :: ToJSON a => a -> IO ()

-- | Write a JSON-RPC 2.0 message to stdout from an Encoding
putEncoding :: Encoding -> IO ()


-- | JSON-RPC 2.0
--   
--   <a>http://www.jsonrpc.org/specification</a>
module Coda.Message.Base

-- | A JSON-RPC message identifier
data Id
IntId :: !Int -> Id
TextId :: !Text -> Id

-- | <a>http://www.jsonrpc.org/specification#request_object</a>
--   
--   <tt><a>Request</a> <a>Id</a> <a>Value</a></tt> models
--   
--   <pre>
--   interface RequestMessage extends Message {
--     id: number | string;
--     method: string;
--     params?: any
--   }
--   </pre>
--   
--   <tt><a>Request</a> (<a>Maybe</a> <a>Id</a>) <a>Value</a></tt> models
--   either a <tt>RequestMessage</tt> or a <a>Notification</a>.
data Request i a
Request :: !i -> !Text -> !a -> Request i a
[requestId] :: Request i a -> !i
[requestMethod] :: Request i a -> !Text
[requestParams] :: Request i a -> !a
type Request_ = Request Id Value
_RequestNotification :: Prism' (Request (Maybe Id) a) (Notification a)

-- | JSON-RPC 2.0 notifications
--   
--   <pre>
--   interface NotificationMessage extends Message {
--     method: string;
--     params?: any
--   }
--   </pre>
--   
--   <a>Notification</a> is isomorphic to 'Request Nil'
data Notification a
Notification :: !Text -> !a -> Notification a
[notificationMethod] :: Notification a -> !Text
[notificationParams] :: Notification a -> !a
type Notification_ = Notification Value

-- | <a>http://www.jsonrpc.org/specification#response_object</a>
--   
--   @'Response (Maybe Id) Value' models
--   
--   <pre>
--   interface ResponseMessage extends Message {
--     id: number | string | null;
--     result?: any;
--     error?: ResponseError<a>any</a>;
--   }
--   </pre>
data Response e i a
Response :: !i -> !a -> !(Maybe (ResponseError e)) -> Response e i a
[responseId] :: Response e i a -> !i
[responseResult] :: Response e i a -> !a
[responseError] :: Response e i a -> !(Maybe (ResponseError e))
type Response_ = Response Value (Maybe Id) Value

-- | <a>http://www.jsonrpc.org/specification#error_object</a>
--   
--   <pre>
--   interface ResponseError<a>D</a> {
--     code: number;
--     message: string;
--     data?: D;
--   }
--   </pre>
data ResponseError a
ResponseError :: !ErrorCode -> !Text -> !a -> ResponseError a
[responseErrorCode] :: ResponseError a -> !ErrorCode
[responseErrorMessage] :: ResponseError a -> !Text
[responseErrorData] :: ResponseError a -> !a
type ResponseError_ = ResponseError Value

-- | <a>http://www.jsonrpc.org/specification#error_object</a>
newtype ErrorCode
ErrorCode :: Int -> ErrorCode
class HasId t
id_ :: HasId t => Lens (t a c) (t b c) a b
class HasParams f
params :: HasParams f => Lens (f a) (f b) a b
class HasMethod t
method :: HasMethod t => Lens' t Text
instance Data.Traversable.Traversable (Coda.Message.Base.Response e i)
instance Data.Foldable.Foldable (Coda.Message.Base.Response e i)
instance GHC.Base.Functor (Coda.Message.Base.Response e i)
instance GHC.Generics.Generic1 (Coda.Message.Base.Response e i)
instance GHC.Generics.Generic (Coda.Message.Base.Response e i a)
instance (Data.Data.Data e, Data.Data.Data i, Data.Data.Data a) => Data.Data.Data (Coda.Message.Base.Response e i a)
instance (GHC.Read.Read e, GHC.Read.Read i, GHC.Read.Read a) => GHC.Read.Read (Coda.Message.Base.Response e i a)
instance (GHC.Show.Show e, GHC.Show.Show i, GHC.Show.Show a) => GHC.Show.Show (Coda.Message.Base.Response e i a)
instance (GHC.Classes.Eq e, GHC.Classes.Eq i, GHC.Classes.Eq a) => GHC.Classes.Eq (Coda.Message.Base.Response e i a)
instance GHC.Generics.Generic1 Coda.Message.Base.ResponseError
instance GHC.Generics.Generic (Coda.Message.Base.ResponseError a)
instance Data.Data.Data a => Data.Data.Data (Coda.Message.Base.ResponseError a)
instance GHC.Read.Read a => GHC.Read.Read (Coda.Message.Base.ResponseError a)
instance GHC.Show.Show a => GHC.Show.Show (Coda.Message.Base.ResponseError a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Coda.Message.Base.ResponseError a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Coda.Message.Base.ResponseError a)
instance GHC.Generics.Generic Coda.Message.Base.ErrorCode
instance Data.Data.Data Coda.Message.Base.ErrorCode
instance GHC.Arr.Ix Coda.Message.Base.ErrorCode
instance GHC.Enum.Bounded Coda.Message.Base.ErrorCode
instance GHC.Read.Read Coda.Message.Base.ErrorCode
instance GHC.Classes.Ord Coda.Message.Base.ErrorCode
instance GHC.Classes.Eq Coda.Message.Base.ErrorCode
instance GHC.Show.Show Coda.Message.Base.ErrorCode
instance Data.Traversable.Traversable Coda.Message.Base.Notification
instance Data.Foldable.Foldable Coda.Message.Base.Notification
instance GHC.Base.Functor Coda.Message.Base.Notification
instance GHC.Generics.Generic1 Coda.Message.Base.Notification
instance GHC.Generics.Generic (Coda.Message.Base.Notification a)
instance Data.Data.Data a => Data.Data.Data (Coda.Message.Base.Notification a)
instance GHC.Read.Read a => GHC.Read.Read (Coda.Message.Base.Notification a)
instance GHC.Show.Show a => GHC.Show.Show (Coda.Message.Base.Notification a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Coda.Message.Base.Notification a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Coda.Message.Base.Notification a)
instance Data.Traversable.Traversable (Coda.Message.Base.Request i)
instance Data.Foldable.Foldable (Coda.Message.Base.Request i)
instance GHC.Base.Functor (Coda.Message.Base.Request i)
instance GHC.Generics.Generic1 (Coda.Message.Base.Request i)
instance GHC.Generics.Generic (Coda.Message.Base.Request i a)
instance (Data.Data.Data i, Data.Data.Data a) => Data.Data.Data (Coda.Message.Base.Request i a)
instance (GHC.Read.Read i, GHC.Read.Read a) => GHC.Read.Read (Coda.Message.Base.Request i a)
instance (GHC.Show.Show i, GHC.Show.Show a) => GHC.Show.Show (Coda.Message.Base.Request i a)
instance (GHC.Classes.Ord i, GHC.Classes.Ord a) => GHC.Classes.Ord (Coda.Message.Base.Request i a)
instance (GHC.Classes.Eq i, GHC.Classes.Eq a) => GHC.Classes.Eq (Coda.Message.Base.Request i a)
instance GHC.Enum.Bounded Coda.Message.Base.Nil
instance GHC.Arr.Ix Coda.Message.Base.Nil
instance GHC.Generics.Generic Coda.Message.Base.Nil
instance Data.Data.Data Coda.Message.Base.Nil
instance GHC.Read.Read Coda.Message.Base.Nil
instance GHC.Show.Show Coda.Message.Base.Nil
instance GHC.Classes.Ord Coda.Message.Base.Nil
instance GHC.Classes.Eq Coda.Message.Base.Nil
instance GHC.Generics.Generic Coda.Message.Base.Id
instance Data.Data.Data Coda.Message.Base.Id
instance GHC.Read.Read Coda.Message.Base.Id
instance GHC.Show.Show Coda.Message.Base.Id
instance GHC.Classes.Ord Coda.Message.Base.Id
instance GHC.Classes.Eq Coda.Message.Base.Id
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Base.Id
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Base.Id
instance Data.String.IsString Coda.Message.Base.Id
instance Data.Hashable.Class.Hashable Coda.Message.Base.Id
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Base.Nil
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Base.Nil
instance Data.Hashable.Class.Hashable Coda.Message.Base.Nil
instance Coda.Message.Base.HasId Coda.Message.Base.Request
instance Coda.Message.Base.HasMethod (Coda.Message.Base.Request i a)
instance Coda.Message.Base.HasParams (Coda.Message.Base.Request i)
instance (Data.Aeson.Types.FromJSON.FromJSON i, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Coda.Message.Base.Request i a)
instance (Data.Aeson.Types.ToJSON.ToJSON i, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Coda.Message.Base.Request i a)
instance Control.Comonad.Comonad (Coda.Message.Base.Request i)
instance Data.Bitraversable.Bitraversable Coda.Message.Base.Request
instance Data.Bifoldable.Bifoldable Coda.Message.Base.Request
instance Data.Bifunctor.Bifunctor Coda.Message.Base.Request
instance Data.Hashable.Class.Hashable2 Coda.Message.Base.Request
instance Data.Hashable.Class.Hashable i => Data.Hashable.Class.Hashable1 (Coda.Message.Base.Request i)
instance (Data.Hashable.Class.Hashable i, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Coda.Message.Base.Request i a)
instance Coda.Message.Base.HasMethod (Coda.Message.Base.Notification a)
instance Coda.Message.Base.HasParams Coda.Message.Base.Notification
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Coda.Message.Base.Notification a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Coda.Message.Base.Notification a)
instance Control.Comonad.Comonad Coda.Message.Base.Notification
instance Data.Hashable.Class.Hashable1 Coda.Message.Base.Notification
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Coda.Message.Base.Notification a)
instance (Data.Aeson.Types.ToJSON.ToJSON e, Data.Aeson.Types.ToJSON.ToJSON i, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Coda.Message.Base.Response e i a)
instance (Data.Aeson.Types.FromJSON.FromJSON e, Data.Aeson.Types.FromJSON.FromJSON i, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Coda.Message.Base.Response e i a)
instance Coda.Message.Base.HasId (Coda.Message.Base.Response e)
instance Control.Comonad.Comonad (Coda.Message.Base.Response e i)
instance Data.Bifunctor.Bifunctor (Coda.Message.Base.Response e)
instance Data.Bifoldable.Bifoldable (Coda.Message.Base.Response e)
instance Data.Bitraversable.Bitraversable (Coda.Message.Base.Response e)
instance Data.Hashable.Class.Hashable e => Data.Hashable.Class.Hashable2 (Coda.Message.Base.Response e)
instance (Data.Hashable.Class.Hashable e, Data.Hashable.Class.Hashable i) => Data.Hashable.Class.Hashable1 (Coda.Message.Base.Response e i)
instance (Data.Hashable.Class.Hashable e, Data.Hashable.Class.Hashable i, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Coda.Message.Base.Response e i a)
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Base.ErrorCode
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Base.ErrorCode
instance Data.Hashable.Class.Hashable Coda.Message.Base.ErrorCode
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Coda.Message.Base.ResponseError a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Coda.Message.Base.ResponseError a)
instance Data.Hashable.Class.Hashable1 Coda.Message.Base.ResponseError
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Coda.Message.Base.ResponseError a)


-- | <a>Language Server Protocol</a>
module Coda.Message.Language

-- | Note: You should still reply to the item in question
--   
--   
--   <a>https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#-cancellation-support</a>
_CancelRequest :: Prism' Notification_ Id
cancelledResponse :: Id -> Response Value Id Value

-- | |
--   <a>https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#uri</a>
type DocumentUri = Text

-- | 
--   <a>https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#position</a>
--   
--   <pre>
--   interface <a>Position</a> {
--     line: number;
--     character: number;
--   }
--   </pre>
data Position
Position :: !Int -> !Int -> Position

-- | 0-based line number
[positionLine] :: Position -> !Int

-- | 0-based count of utf-16 words (not code-points!)
[positionCharacter] :: Position -> !Int

-- | 
--   <a>https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#range</a>
--   
--   <pre>
--   interface <a>Range</a> {
--     start: <a>Position</a>;
--     end: <a>Position</a>;
--   }
--   </pre>
data Range
Range :: !Position -> !Position -> Range
[_rangeStart] :: Range -> !Position
[_rangeEnd] :: Range -> !Position

-- | 
--   <a>https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#location</a>
--   
--   <pre>
--   interface <a>Location</a> {
--     uri: <a>DocumentUri</a>;
--     range: <a>Range</a>;
--   }
--   </pre>
data Location
Location :: DocumentUri -> Range -> Location
[locationUri] :: Location -> DocumentUri
[locationRange] :: Location -> Range

-- | 
--   <a>https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#diagnostic</a>
--   
--   <pre>
--   interface <a>Diagnostic</a> {
--     range: <a>Range</a>;
--     severity?: number;
--     code?: number | string;
--     source?: string;
--     message: string;
--   }
--   </pre>
data Diagnostic
Diagnostic :: !Range -> !(Maybe Severity) -> !(Maybe Id) -> !(Maybe Text) -> !Text -> Diagnostic
[diagnosticRange] :: Diagnostic -> !Range
[diagnosticSeverity] :: Diagnostic -> !(Maybe Severity)
[diagnosticCode] :: Diagnostic -> !(Maybe Id)
[diagnosticSource] :: Diagnostic -> !(Maybe Text)
[diagnosticMessage] :: Diagnostic -> !Text

-- | 
--   <a>https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#command</a>
--   
--   <pre>
--   interface <a>Command</a> {
--     title : string;
--     command: string;
--     arguments?: any[]
--   }
--   </pre>
data Command a
Command :: Text -> Text -> Maybe [a] -> Command a
[commandTitle] :: Command a -> Text
[commandCommand] :: Command a -> Text
[commandArguments] :: Command a -> Maybe [a]
type Command_ = Command Value

-- | 
--   <a>https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#textedit</a>
--   
--   <pre>
--   interface <a>TextEdit</a> {
--     range: <a>Range</a>;
--     newText: string;
--   }
--   </pre>
data TextEdit
TextEdit :: Range -> Text -> TextEdit
[textEditRange] :: TextEdit -> Range
[textEditNewText] :: TextEdit -> Text

-- | 
--   <a>https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#textdocumentidentifier</a>
--   
--   <pre>
--   interface <a>TextDocumentIdentifier</a> {
--     uri : <a>DocumentUri</a>
--   }
--   </pre>
newtype TextDocumentIdentifier
TextDocumentIdentifier :: DocumentUri -> TextDocumentIdentifier
[textDocumentIdentifierUri] :: TextDocumentIdentifier -> DocumentUri

-- | 
--   <a>https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#versionedtextdocumentidentifier</a>
--   
--   <pre>
--   interface <a>VersionedTextDocumentIdentifier</a> extends <a>TextDocumentIdentifier</a> {
--     version: number;
--   }
--   </pre>
data VersionedTextDocumentIdentifier
VersionedTextDocumentIdentifier :: !DocumentUri -> !Int -> VersionedTextDocumentIdentifier
[versionedTextDocumentIdentifierUri] :: VersionedTextDocumentIdentifier -> !DocumentUri
[versionedTextDocumentIdentifierVersion] :: VersionedTextDocumentIdentifier -> !Int

-- | An item to transfer a text document from the client to the server.
--   
--   
--   <a>https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md#textdocumentitem</a>
--   
--   <pre>
--   interface TextDocumentItem {
--     uri: DocumentUri;
--     languageId: string;
--     version: number;
--     text: string;
--   }
--   </pre>
data TextDocumentItem
TextDocumentItem :: !DocumentUri -> !Text -> !Int -> !Text -> TextDocumentItem
[textDocumentItemUri] :: TextDocumentItem -> !DocumentUri
[textDocumentItemLanguageId] :: TextDocumentItem -> !Text
[textDocumentItemVersion] :: TextDocumentItem -> !Int
[textDocumentItemText] :: TextDocumentItem -> !Text
data TextDocumentEdit
TextDocumentEdit :: !VersionedTextDocumentIdentifier -> [TextEdit] -> TextDocumentEdit
[textDocumentEditTextDocument] :: TextDocumentEdit -> !VersionedTextDocumentIdentifier
[textDocumentEditEdits] :: TextDocumentEdit -> [TextEdit]
newtype UriMap a
UriMap :: HashMap Text a -> UriMap a
[runUriMap] :: UriMap a -> HashMap Text a
data WorkspaceEdit
WorkspaceEdit :: !(Maybe (UriMap [TextEdit])) -> !(Maybe [TextDocumentEdit]) -> WorkspaceEdit
[workspaceEditChanges] :: WorkspaceEdit -> !(Maybe (UriMap [TextEdit]))
[workspaceEditDocumentChanges] :: WorkspaceEdit -> !(Maybe [TextDocumentEdit])
class HasRange t
range :: HasRange t => Lens' t Range
class HasUri t
uri :: HasUri t => Lens' t DocumentUri
class HasVersion t
version :: HasVersion t => Lens' t Int

-- | Law:
--   
--   <pre>
--   <a>uri</a> = <a>textDocumentIdentifier</a> <a>.</a> <a>uri</a>
--   </pre>
class HasUri t => HasTextDocumentIdentifier t
textDocumentIdentifier :: HasTextDocumentIdentifier t => Lens' t TextDocumentIdentifier

-- | Laws:
--   
--   <pre>
--   <a>textDocumentIdentifier</a> = <a>versionedTextDocumentIdentifier</a> <a>.</a> <a>textDocumentIdentifier</a>
--   <a>version</a> = <a>versionedTextDocumentIdentifier</a> <a>.</a> <a>version</a>
--   </pre>
class (HasVersion t, HasTextDocumentIdentifier t) => HasVersionedTextDocumentIdentifier t
versionedTextDocumentIdentifier :: HasVersionedTextDocumentIdentifier t => Lens' t VersionedTextDocumentIdentifier
instance GHC.Generics.Generic Coda.Message.Language.TextDocumentItem
instance Data.Data.Data Coda.Message.Language.TextDocumentItem
instance GHC.Read.Read Coda.Message.Language.TextDocumentItem
instance GHC.Show.Show Coda.Message.Language.TextDocumentItem
instance GHC.Classes.Ord Coda.Message.Language.TextDocumentItem
instance GHC.Classes.Eq Coda.Message.Language.TextDocumentItem
instance GHC.Generics.Generic Coda.Message.Language.WorkspaceEdit
instance Data.Data.Data Coda.Message.Language.WorkspaceEdit
instance GHC.Read.Read Coda.Message.Language.WorkspaceEdit
instance GHC.Show.Show Coda.Message.Language.WorkspaceEdit
instance GHC.Classes.Eq Coda.Message.Language.WorkspaceEdit
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Coda.Message.Language.UriMap a)
instance Data.Hashable.Class.Hashable1 Coda.Message.Language.UriMap
instance Data.Traversable.Traversable Coda.Message.Language.UriMap
instance Data.Foldable.Foldable Coda.Message.Language.UriMap
instance GHC.Generics.Generic1 Coda.Message.Language.UriMap
instance GHC.Generics.Generic (Coda.Message.Language.UriMap a)
instance Data.Data.Data a => Data.Data.Data (Coda.Message.Language.UriMap a)
instance GHC.Base.Functor Coda.Message.Language.UriMap
instance GHC.Read.Read a => GHC.Read.Read (Coda.Message.Language.UriMap a)
instance GHC.Show.Show a => GHC.Show.Show (Coda.Message.Language.UriMap a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Coda.Message.Language.UriMap a)
instance GHC.Generics.Generic Coda.Message.Language.TextDocumentEdit
instance Data.Data.Data Coda.Message.Language.TextDocumentEdit
instance GHC.Read.Read Coda.Message.Language.TextDocumentEdit
instance GHC.Show.Show Coda.Message.Language.TextDocumentEdit
instance GHC.Classes.Ord Coda.Message.Language.TextDocumentEdit
instance GHC.Classes.Eq Coda.Message.Language.TextDocumentEdit
instance GHC.Generics.Generic Coda.Message.Language.VersionedTextDocumentIdentifier
instance Data.Data.Data Coda.Message.Language.VersionedTextDocumentIdentifier
instance GHC.Read.Read Coda.Message.Language.VersionedTextDocumentIdentifier
instance GHC.Show.Show Coda.Message.Language.VersionedTextDocumentIdentifier
instance GHC.Classes.Ord Coda.Message.Language.VersionedTextDocumentIdentifier
instance GHC.Classes.Eq Coda.Message.Language.VersionedTextDocumentIdentifier
instance GHC.Generics.Generic Coda.Message.Language.TextDocumentIdentifier
instance Data.Data.Data Coda.Message.Language.TextDocumentIdentifier
instance GHC.Read.Read Coda.Message.Language.TextDocumentIdentifier
instance GHC.Show.Show Coda.Message.Language.TextDocumentIdentifier
instance GHC.Classes.Ord Coda.Message.Language.TextDocumentIdentifier
instance GHC.Classes.Eq Coda.Message.Language.TextDocumentIdentifier
instance GHC.Generics.Generic Coda.Message.Language.TextEdit
instance Data.Data.Data Coda.Message.Language.TextEdit
instance GHC.Read.Read Coda.Message.Language.TextEdit
instance GHC.Show.Show Coda.Message.Language.TextEdit
instance GHC.Classes.Ord Coda.Message.Language.TextEdit
instance GHC.Classes.Eq Coda.Message.Language.TextEdit
instance Data.Traversable.Traversable Coda.Message.Language.Command
instance Data.Foldable.Foldable Coda.Message.Language.Command
instance GHC.Base.Functor Coda.Message.Language.Command
instance GHC.Generics.Generic1 Coda.Message.Language.Command
instance GHC.Generics.Generic (Coda.Message.Language.Command a)
instance Data.Data.Data a => Data.Data.Data (Coda.Message.Language.Command a)
instance GHC.Read.Read a => GHC.Read.Read (Coda.Message.Language.Command a)
instance GHC.Show.Show a => GHC.Show.Show (Coda.Message.Language.Command a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Coda.Message.Language.Command a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Coda.Message.Language.Command a)
instance GHC.Generics.Generic Coda.Message.Language.Diagnostic
instance Data.Data.Data Coda.Message.Language.Diagnostic
instance GHC.Read.Read Coda.Message.Language.Diagnostic
instance GHC.Show.Show Coda.Message.Language.Diagnostic
instance GHC.Classes.Ord Coda.Message.Language.Diagnostic
instance GHC.Classes.Eq Coda.Message.Language.Diagnostic
instance GHC.Generics.Generic Coda.Message.Language.Location
instance Data.Data.Data Coda.Message.Language.Location
instance GHC.Read.Read Coda.Message.Language.Location
instance GHC.Show.Show Coda.Message.Language.Location
instance GHC.Classes.Ord Coda.Message.Language.Location
instance GHC.Classes.Eq Coda.Message.Language.Location
instance GHC.Generics.Generic Coda.Message.Language.Range
instance Data.Data.Data Coda.Message.Language.Range
instance GHC.Read.Read Coda.Message.Language.Range
instance GHC.Show.Show Coda.Message.Language.Range
instance GHC.Classes.Ord Coda.Message.Language.Range
instance GHC.Classes.Eq Coda.Message.Language.Range
instance GHC.Generics.Generic Coda.Message.Language.Position
instance Data.Data.Data Coda.Message.Language.Position
instance GHC.Read.Read Coda.Message.Language.Position
instance GHC.Show.Show Coda.Message.Language.Position
instance GHC.Classes.Ord Coda.Message.Language.Position
instance GHC.Classes.Eq Coda.Message.Language.Position
instance GHC.Generics.Generic Coda.Message.Language.LineEnding
instance Data.Data.Data Coda.Message.Language.LineEnding
instance GHC.Enum.Bounded Coda.Message.Language.LineEnding
instance GHC.Enum.Enum Coda.Message.Language.LineEnding
instance GHC.Arr.Ix Coda.Message.Language.LineEnding
instance GHC.Read.Read Coda.Message.Language.LineEnding
instance GHC.Show.Show Coda.Message.Language.LineEnding
instance GHC.Classes.Ord Coda.Message.Language.LineEnding
instance GHC.Classes.Eq Coda.Message.Language.LineEnding
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Language.LineEnding
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Language.LineEnding
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Language.Position
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Language.Position
instance Data.Hashable.Class.Hashable Coda.Message.Language.Position
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Language.Range
instance Coda.Message.Language.HasRange Coda.Message.Language.Range
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Language.Range
instance Data.Hashable.Class.Hashable Coda.Message.Language.Range
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Language.Location
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Language.Location
instance Data.Hashable.Class.Hashable Coda.Message.Language.Location
instance Coda.Message.Language.HasUri Coda.Message.Language.Location
instance Coda.Message.Language.HasRange Coda.Message.Language.Location
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Language.Diagnostic
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Language.Diagnostic
instance Data.Hashable.Class.Hashable Coda.Message.Language.Diagnostic
instance Coda.Message.Language.HasRange Coda.Message.Language.Diagnostic
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Coda.Message.Language.Command a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Coda.Message.Language.Command a)
instance Data.Hashable.Class.Hashable1 Coda.Message.Language.Command
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Coda.Message.Language.Command a)
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Language.TextEdit
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Language.TextEdit
instance Data.Hashable.Class.Hashable Coda.Message.Language.TextEdit
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Language.TextDocumentIdentifier
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Language.TextDocumentIdentifier
instance Data.Hashable.Class.Hashable Coda.Message.Language.TextDocumentIdentifier
instance Coda.Message.Language.HasUri Coda.Message.Language.TextDocumentIdentifier
instance Coda.Message.Language.HasTextDocumentIdentifier Coda.Message.Language.TextDocumentIdentifier
instance Coda.Message.Language.HasVersion Coda.Message.Language.VersionedTextDocumentIdentifier
instance Coda.Message.Language.HasUri Coda.Message.Language.VersionedTextDocumentIdentifier
instance Coda.Message.Language.HasTextDocumentIdentifier Coda.Message.Language.VersionedTextDocumentIdentifier
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Language.VersionedTextDocumentIdentifier
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Language.VersionedTextDocumentIdentifier
instance Data.Hashable.Class.Hashable Coda.Message.Language.VersionedTextDocumentIdentifier
instance Coda.Message.Language.HasVersionedTextDocumentIdentifier Coda.Message.Language.VersionedTextDocumentIdentifier
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Language.TextDocumentEdit
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Language.TextDocumentEdit
instance Data.Hashable.Class.Hashable Coda.Message.Language.TextDocumentEdit
instance Coda.Message.Language.HasUri Coda.Message.Language.TextDocumentEdit
instance Coda.Message.Language.HasTextDocumentIdentifier Coda.Message.Language.TextDocumentEdit
instance Coda.Message.Language.HasVersion Coda.Message.Language.TextDocumentEdit
instance Coda.Message.Language.HasVersionedTextDocumentIdentifier Coda.Message.Language.TextDocumentEdit
instance Data.Aeson.Types.ToJSON.ToJSON1 Coda.Message.Language.UriMap
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Coda.Message.Language.UriMap a)
instance Data.Hashable.Class.Hashable Coda.Message.Language.TextDocumentItem
instance Data.Aeson.Types.ToJSON.ToJSON Coda.Message.Language.TextDocumentItem
instance Data.Aeson.Types.FromJSON.FromJSON Coda.Message.Language.TextDocumentItem
instance Coda.Message.Language.HasUri Coda.Message.Language.TextDocumentItem
instance Coda.Message.Language.HasVersion Coda.Message.Language.TextDocumentItem
instance Coda.Message.Language.HasTextDocumentIdentifier Coda.Message.Language.TextDocumentItem
instance Coda.Message.Language.HasVersionedTextDocumentIdentifier Coda.Message.Language.TextDocumentItem

module Coda.Data.View
data ViewL f a
EmptyL :: ViewL f a
(:<) :: !a -> !(f a) -> ViewL f a
data ViewR f a
EmptyR :: ViewR f a
(:>) :: !(f a) -> !a -> ViewR f a
class ViewableL f
viewL :: ViewableL f => f a -> ViewL f a
class ViewableR f
viewR :: ViewableR f => f a -> ViewR f a
instance GHC.Generics.Generic1 (Coda.Data.View.ViewR f)
instance GHC.Generics.Generic (Coda.Data.View.ViewR f a)
instance (Data.Data.Data a, Data.Data.Data (f a), Data.Typeable.Internal.Typeable f) => Data.Data.Data (Coda.Data.View.ViewR f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Coda.Data.View.ViewR f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Coda.Data.View.ViewR f)
instance GHC.Base.Functor f => GHC.Base.Functor (Coda.Data.View.ViewR f)
instance (GHC.Read.Read a, GHC.Read.Read (f a)) => GHC.Read.Read (Coda.Data.View.ViewR f a)
instance (GHC.Show.Show a, GHC.Show.Show (f a)) => GHC.Show.Show (Coda.Data.View.ViewR f a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord (f a)) => GHC.Classes.Ord (Coda.Data.View.ViewR f a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (f a)) => GHC.Classes.Eq (Coda.Data.View.ViewR f a)
instance GHC.Generics.Generic1 (Coda.Data.View.ViewL f)
instance GHC.Generics.Generic (Coda.Data.View.ViewL f a)
instance (Data.Data.Data a, Data.Data.Data (f a), Data.Typeable.Internal.Typeable f) => Data.Data.Data (Coda.Data.View.ViewL f a)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Coda.Data.View.ViewL f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Coda.Data.View.ViewL f)
instance GHC.Base.Functor f => GHC.Base.Functor (Coda.Data.View.ViewL f)
instance (GHC.Read.Read a, GHC.Read.Read (f a)) => GHC.Read.Read (Coda.Data.View.ViewL f a)
instance (GHC.Show.Show a, GHC.Show.Show (f a)) => GHC.Show.Show (Coda.Data.View.ViewL f a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord (f a)) => GHC.Classes.Ord (Coda.Data.View.ViewL f a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (f a)) => GHC.Classes.Eq (Coda.Data.View.ViewL f a)


module Coda.Data.Sink

-- | A contravariant message sink
newtype Sink a
Sink :: (a -> IO ()) -> Sink a
[sink] :: Sink a -> a -> IO ()
instance Data.Functor.Contravariant.Contravariant Coda.Data.Sink.Sink
instance Data.Functor.Contravariant.Divisible.Divisible Coda.Data.Sink.Sink
instance Data.Functor.Contravariant.Divisible.Decidable Coda.Data.Sink.Sink


module Coda.Server
server :: ServerOptions -> IO ()

module Coda.Data.Queue

-- | A fast functional queue
data Queue a
Q0 :: Queue a
Q1 :: a -> Queue a
QN :: !(B a) -> !(Queue (P a)) -> !(B a) -> Queue a

-- | &lt;math&gt;
snoc :: Queue a -> a -> Queue a

-- | &lt;math&gt;
uncons :: Queue a -> Maybe (a, Queue a)
instance Data.Traversable.Traversable Coda.Data.Queue.Queue
instance GHC.Base.Functor Coda.Data.Queue.Queue
instance GHC.Show.Show a => GHC.Show.Show (Coda.Data.Queue.Queue a)
instance Data.Traversable.Traversable Coda.Data.Queue.B
instance Data.Foldable.Foldable Coda.Data.Queue.B
instance GHC.Base.Functor Coda.Data.Queue.B
instance GHC.Show.Show a => GHC.Show.Show (Coda.Data.Queue.B a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Coda.Data.Queue.B a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Coda.Data.Queue.B a)
instance Data.Traversable.Traversable Coda.Data.Queue.P
instance Data.Foldable.Foldable Coda.Data.Queue.P
instance GHC.Base.Functor Coda.Data.Queue.P
instance GHC.Show.Show a => GHC.Show.Show (Coda.Data.Queue.P a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Coda.Data.Queue.P a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Coda.Data.Queue.P a)
instance Data.Foldable.Foldable Coda.Data.Queue.Queue
instance Control.Lens.Empty.AsEmpty (Coda.Data.Queue.Queue a)
instance GHC.Exts.IsList (Coda.Data.Queue.Queue a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Coda.Data.Queue.Queue a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Coda.Data.Queue.Queue a)
instance Coda.Data.View.ViewableL Coda.Data.Queue.Queue

module Coda.Data.List

-- | An Okasaki-style catenable list
--   
--   <a>mappend</a>, <a>cons</a>, <a>snoc</a>, <a>uncons</a> are all
--   &lt;math&gt;
--   
--   Use <tt>(<a>Empty</a>, <a>:&lt;</a>)</tt> from <tt>Control.Lens</tt>
--   to get a traditional list like view.
data List a
Nil :: List a
Cons :: !a -> !(Queue (List a)) -> List a

-- | &lt;math&gt; in <tt>k</tt> the number of characters being dropped.
drop :: Int -> List a -> List a

-- | Concatenate a queue of catenable lists
--   
--   &lt;math&gt; where <tt>e</tt> is the number of empty entries in the
--   queue
flatten :: Queue (List a) -> List a
instance Data.Traversable.Traversable Coda.Data.List.List
instance GHC.Base.Functor Coda.Data.List.List
instance GHC.Show.Show a => GHC.Show.Show (Coda.Data.List.List a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Coda.Data.List.List a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Coda.Data.List.List a)
instance Data.Foldable.Foldable Coda.Data.List.List
instance GHC.Base.Applicative Coda.Data.List.List
instance GHC.Base.Monad Coda.Data.List.List
instance GHC.Base.Alternative Coda.Data.List.List
instance GHC.Base.MonadPlus Coda.Data.List.List
instance Data.Semigroup.Semigroup (Coda.Data.List.List a)
instance GHC.Base.Monoid (Coda.Data.List.List a)
instance Coda.Data.View.ViewableL Coda.Data.List.List
instance Control.Lens.Cons.Cons (Coda.Data.List.List a) (Coda.Data.List.List b) a b
instance Control.Lens.Empty.AsEmpty (Coda.Data.List.List a)
instance Control.Monad.Zip.MonadZip Coda.Data.List.List
instance GHC.Exts.IsList (Coda.Data.List.List a)

module Coda.Syntax.Line

-- | Invariants
--   
--   <ul>
--   <li>The only occurrences of '\n', '\r' or "rn" are at the end of the
--   ByteArray</li>
--   <li>Valid UTF-8 encoding TODO: store if the line is ASCII?</li>
--   </ul>
newtype Line
Line :: ByteArray -> Line
(!!) :: Line -> Int -> Word8
encodeLine :: Text -> Either EncodingError Line
data EncodingError
EncodingError :: Delta -> String -> EncodingError

-- | Invariants:
--   
--   <ul>
--   <li>all lines in <a>alexInputLines</a> are non-empty</li>
--   </ul>
data AlexInput
AlexInput :: {-# UNPACK #-} !Delta -> !(List Line) -> AlexInput
[alexInputDelta] :: AlexInput -> {-# UNPACK #-} !Delta
[alexInputLines] :: AlexInput -> !(List Line)

-- | <pre>
--   &gt;&gt;&gt; alexInputPrevChar $ AlexInput (Delta 0 1 1) ["a"]
--   'a'
--   </pre>
alexInputPrevChar :: AlexInput -> Char
advanceInput :: AlexInput -> Delta -> AlexInput

-- | Ideally we'd simply provide a monoid <a>Delta</a> that acts on
--   <a>AlexInput</a> but <tt>alex</tt> isn't that sophisticated.
--   
--   <pre>
--   &gt;&gt;&gt; List.unfoldr alexGetByte $ AlexInput mempty ["hello\n","world"]
--   [104,101,108,108,111,10,119,111,114,108,100]
--   </pre>
alexGetByte :: AlexInput -> Maybe (Word8, AlexInput)
instance GHC.Show.Show Coda.Syntax.Line.AlexInput
instance GHC.Show.Show Coda.Syntax.Line.EncodingError
instance GHC.Classes.Eq Coda.Syntax.Line.Line
instance GHC.Show.Show Coda.Syntax.Line.Line
instance Coda.Syntax.Delta.Relative Coda.Syntax.Line.EncodingError
instance Data.String.IsString Coda.Syntax.Line.Line
instance GHC.Exts.IsList Coda.Syntax.Line.Line
instance Control.Lens.Empty.AsEmpty Coda.Syntax.Line.Line


module Coda.Console.Unicode

-- | Run in a modified codepage where we can print UTF-8 values on Windows.
--   
--   You should probably run the top level of your program in this.
withUnicode :: MonadCatch m => m a -> m a


module Coda.Console.Options

-- | Options for <tt>coda repl</tt>
data ConsoleOptions
ConsoleOptions :: Bool -> Bool -> ConsoleOptions
[_consoleOptionsNoHeading] :: ConsoleOptions -> Bool
[_consoleOptionsNoUnicode] :: ConsoleOptions -> Bool
class HasConsoleOptions c_a3IiD where consoleOptionsNoHeading = (.) consoleOptions consoleOptionsNoHeading consoleOptionsNoUnicode = (.) consoleOptions consoleOptionsNoUnicode
consoleOptions :: HasConsoleOptions c_a3IiD => Lens' c_a3IiD ConsoleOptions
consoleOptionsNoHeading :: HasConsoleOptions c_a3IiD => Lens' c_a3IiD Bool
consoleOptionsNoUnicode :: HasConsoleOptions c_a3IiD => Lens' c_a3IiD Bool

-- | Parse <tt>coda repl</tt> options
parseConsoleOptions :: Parser ConsoleOptions
instance Coda.Console.Options.HasConsoleOptions Coda.Console.Options.ConsoleOptions
instance GHC.Read.Read Coda.Console.Options.ConsoleOptions
instance GHC.Show.Show Coda.Console.Options.ConsoleOptions
instance GHC.Classes.Ord Coda.Console.Options.ConsoleOptions
instance GHC.Classes.Eq Coda.Console.Options.ConsoleOptions


module Coda.Console.Command
data Command
Command :: String -> [String] -> Maybe String -> Maybe (CompletionFunc IO) -> String -> ([String] -> String -> IO ()) -> Command
[_cmdName] :: Command -> String
[_alts] :: Command -> [String]
[_arg] :: Command -> Maybe String
[_tabbed] :: Command -> Maybe (CompletionFunc IO)
[_desc] :: Command -> String
[_body] :: Command -> [String] -> String -> IO ()
class HasCommand c_a3KNf where alts = (.) command alts arg = (.) command arg body = (.) command body cmdName = (.) command cmdName desc = (.) command desc tabbed = (.) command tabbed
command :: HasCommand c_a3KNf => Lens' c_a3KNf Command
alts :: HasCommand c_a3KNf => Lens' c_a3KNf [String]
arg :: HasCommand c_a3KNf => Lens' c_a3KNf (Maybe String)
body :: HasCommand c_a3KNf => Lens' c_a3KNf ([String] -> String -> IO ())
cmdName :: HasCommand c_a3KNf => Lens' c_a3KNf String
desc :: HasCommand c_a3KNf => Lens' c_a3KNf String
tabbed :: HasCommand c_a3KNf => Lens' c_a3KNf (Maybe (CompletionFunc IO))
commands :: [Command]
executeCommand :: String -> IO ()
instance Coda.Console.Command.HasCommand Coda.Console.Command.Command


module Coda.Console.Completion

-- | Haskeline settings supporting autocomplete and persistent history
settings :: Settings IO


-- | Start a REPL
module Coda.Console
heading :: String
console :: ConsoleOptions -> IO ()
